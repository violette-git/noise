# Web Audio API Noise Generation and Recording Techniques

## Table of Contents
1. [Introduction](#introduction)
2. [Noise Types and Mathematical Characteristics](#noise-types-and-mathematical-characteristics)
3. [Web Audio API Noise Generation](#web-audio-api-noise-generation)
4. [Audio Recording in the Browser](#audio-recording-in-the-browser)
5. [Browser Compatibility and Limitations](#browser-compatibility-and-limitations)
6. [Implementation Examples](#implementation-examples)
7. [Conclusion](#conclusion)

## Introduction

The Web Audio API provides a powerful system for controlling audio in the browser, offering capabilities for generating, processing, and analyzing audio. This report focuses on noise generation techniques, the mathematical differences between noise types, and methods for recording audio in web browsers.

## Noise Types and Mathematical Characteristics

Different types of noise are characterized by their spectral density distribution:

### White Noise (β = 0)
- **Spectral Characteristics**: Flat spectral density with equal power across all frequencies
- **Mathematical Properties**: Uniform energy distribution
- **Sound Quality**: Sounds like static or uniform hiss
- **Use Cases**: Masking background sounds, sound synthesis

### Pink Noise (β = 1)
- **Spectral Characteristics**: Power spectral density inversely proportional to frequency (1/f)
- **Mathematical Properties**: Each octave interval carries equal noise energy
- **Sound Quality**: More balanced and bassier than white noise
- **Use Cases**: Audio testing, sleep aid, concentration enhancement

### Brown Noise (β = 2)
- **Spectral Characteristics**: Power decreases by 6dB per octave
- **Mathematical Properties**: Essentially the square of pink noise
- **Sound Quality**: Emphasizes lower frequencies, sounds like waves or deep rumbling
- **Use Cases**: Relaxation, sleep aid, masking low-frequency environmental noise

### Black Noise
- **Spectral Characteristics**: Predominantly silence with occasional random noise
- **Mathematical Properties**: Minimal spectral density across most frequencies
- **Sound Quality**: Mostly silence with occasional bursts of sound
- **Use Cases**: Special audio effects, simulating natural phenomena

## Web Audio API Noise Generation

### Core Technologies
1. **AudioContext**: The foundation for all audio operations
2. **AudioNode**: Building blocks for audio processing
3. **AudioWorklet**: Modern approach for custom audio processing (recommended)
4. **ScriptProcessorNode**: Legacy method (deprecated)

### Noise Generation Approaches

#### White Noise Generation
```javascript
function createWhiteNoiseGenerator(audioContext) {
  const bufferSize = 4096;
  const whiteNoise = audioContext.createScriptProcessor(bufferSize, 1, 1);
  
  whiteNoise.onaudioprocess = function(e) {
    const output = e.outputBuffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      output[i] = Math.random() * 2 - 1;
    }
  };
  
  return whiteNoise;
}
```

#### Pink Noise Generation
Pink noise requires filtering white noise to achieve the 1/f spectral characteristic:

```javascript
function createPinkNoiseGenerator(audioContext) {
  const bufferSize = 4096;
  const pinkNoise = audioContext.createScriptProcessor(bufferSize, 1, 1);
  
  // Pink noise filter coefficients
  const b0 = 0.99765;
  const b1 = 0.96300;
  const b2 = 0.57000;
  const b3 = -0.06000;
  const b4 = -0.53000;
  const b5 = -0.43000;
  const b6 = 0.15000;
  
  let white = new Array(bufferSize);
  let pink = new Array(7);
  for (let i = 0; i < 7; i++) pink[i] = 0.0;
  
  pinkNoise.onaudioprocess = function(e) {
    const output = e.outputBuffer.getChannelData(0);
    
    for (let i = 0; i < bufferSize; i++) {
      white[i] = Math.random() * 2 - 1;
      
      // Apply pink noise filtering
      pink[0] = b0 * white[i] + b1 * pink[0];
      pink[1] = b1 * white[i] + b2 * pink[1];
      pink[2] = b2 * white[i] + b3 * pink[2];
      pink[3] = b3 * white[i] + b4 * pink[3];
      pink[4] = b4 * white[i] + b5 * pink[4];
      pink[5] = b5 * white[i] + b6 * pink[5];
      pink[6] = b6 * white[i] + b0 * pink[6];
      
      output[i] = pink[0] + pink[1] + pink[2] + pink[3] + pink[4] + pink[5] + pink[6];
      output[i] *= 0.15; // Scale to avoid clipping
    }
  };
  
  return pinkNoise;
}
```

#### Brown Noise Generation
Brown noise can be generated by integrating white noise:

```javascript
function createBrownNoiseGenerator(audioContext) {
  const bufferSize = 4096;
  const brownNoise = audioContext.createScriptProcessor(bufferSize, 1, 1);
  
  let lastOut = 0.0;
  
  brownNoise.onaudioprocess = function(e) {
    const output = e.outputBuffer.getChannelData(0);
    
    for (let i = 0; i < bufferSize; i++) {
      const white = Math.random() * 2 - 1;
      
      // Integrate white noise
      output[i] = (lastOut + (0.02 * white)) / 1.02;
      lastOut = output[i];
      output[i] *= 3.5; // Scale to avoid being too quiet
    }
  };
  
  return brownNoise;
}
```

### Modern Implementation with AudioWorklet

The recommended approach is to use AudioWorklet instead of ScriptProcessorNode:

```javascript
// Define the processor
class NoiseProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.noiseType = 'white'; // Default
    this.lastOut = 0.0; // For brown noise
    
    // For pink noise
    this.pinkCoeffs = [0.99765, 0.96300, 0.57000, -0.06000, -0.53000, -0.43000, 0.15000];
    this.pinkState = new Array(7).fill(0);
    
    this.port.onmessage = (event) => {
      if (event.data.type) {
        this.noiseType = event.data.type;
      }
    };
  }
  
  process(inputs, outputs) {
    const output = outputs[0][0];
    
    switch(this.noiseType) {
      case 'white':
        for (let i = 0; i < output.length; i++) {
          output[i] = Math.random() * 2 - 1;
        }
        break;
        
      case 'pink':
        for (let i = 0; i < output.length; i++) {
          const white = Math.random() * 2 - 1;
          
          this.pinkState[0] = 0.99765 * white + 0.96300 * this.pinkState[0];
          this.pinkState[1] = 0.96300 * white + 0.57000 * this.pinkState[1];
          this.pinkState[2] = 0.57000 * white - 0.06000 * this.pinkState[2];
          this.pinkState[3] = -0.06000 * white - 0.53000 * this.pinkState[3];
          this.pinkState[4] = -0.53000 * white - 0.43000 * this.pinkState[4];
          this.pinkState[5] = -0.43000 * white + 0.15000 * this.pinkState[5];
          this.pinkState[6] = 0.15000 * white + 0.99765 * this.pinkState[6];
          
          output[i] = this.pinkState.reduce((sum, val) => sum + val, 0) * 0.15;
        }
        break;
        
      case 'brown':
        for (let i = 0; i < output.length; i++) {
          const white = Math.random() * 2 - 1;
          output[i] = (this.lastOut + (0.02 * white)) / 1.02;
          this.lastOut = output[i];
          output[i] *= 3.5;
        }
        break;
    }
    
    return true;
  }
}

registerProcessor('noise-processor', NoiseProcessor);
```

Usage:

```javascript
async function setupNoiseGenerator() {
  const audioContext = new AudioContext();
  
  // Load the worklet
  await audioContext.audioWorklet.addModule('noise-processor.js');
  
  // Create noise generator
  const noiseGenerator = new AudioWorkletNode(audioContext, 'noise-processor');
  
  // Connect to output
  noiseGenerator.connect(audioContext.destination);
  
  // Change noise type
  function setNoiseType(type) {
    noiseGenerator.port.postMessage({ type });
  }
  
  return {
    start: () => audioContext.resume(),
    stop: () => audioContext.suspend(),
    setNoiseType
  };
}
```

## Audio Recording in the Browser

### Core Technologies
1. **MediaStream Recording API**: Primary API for recording media streams
2. **navigator.mediaDevices.getUserMedia()**: For accessing microphone input
3. **MediaRecorder**: Interface for recording media

### Recording Process

#### Basic Recording Implementation

```javascript
async function setupRecorder() {
  // Request microphone access
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  
  // Create MediaRecorder instance
  const mediaRecorder = new MediaRecorder(stream);
  
  // Store audio chunks
  const audioChunks = [];
  
  // Handle dataavailable event
  mediaRecorder.addEventListener('dataavailable', event => {
    audioChunks.push(event.data);
  });
  
  // Handle recording stop
  mediaRecorder.addEventListener('stop', () => {
    // Create blob from chunks
    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
    
    // Create URL for the blob
    const audioUrl = URL.createObjectURL(audioBlob);
    
    // Create audio element for playback
    const audio = new Audio(audioUrl);
    
    // Provide download link
    const downloadLink = document.createElement('a');
    downloadLink.href = audioUrl;
    downloadLink.download = 'recording.webm';
    downloadLink.innerText = 'Download Recording';
    document.body.appendChild(downloadLink);
  });
  
  return {
    start: () => {
      audioChunks.length = 0;
      mediaRecorder.start();
    },
    stop: () => mediaRecorder.stop(),
    stream
  };
}
```

#### Recording with Different Formats

```javascript
async function setupRecorderWithFormat(mimeType = 'audio/webm') {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  
  // Check if the specified MIME type is supported
  if (!MediaRecorder.isTypeSupported(mimeType)) {
    console.warn(`${mimeType} is not supported, falling back to default`);
    mimeType = '';
  }
  
  const mediaRecorder = new MediaRecorder(stream, { mimeType });
  const audioChunks = [];
  
  mediaRecorder.addEventListener('dataavailable', event => {
    audioChunks.push(event.data);
  });
  
  mediaRecorder.addEventListener('stop', () => {
    const audioBlob = new Blob(audioChunks);
    const audioUrl = URL.createObjectURL(audioBlob);
    
    // Create download link with appropriate extension
    const extension = mimeType.includes('webm') ? 'webm' : 
                      mimeType.includes('ogg') ? 'ogg' : 
                      mimeType.includes('mp4') ? 'mp4' : 'bin';
    
    const downloadLink = document.createElement('a');
    downloadLink.href = audioUrl;
    downloadLink.download = `recording.${extension}`;
    downloadLink.innerText = 'Download Recording';
    document.body.appendChild(downloadLink);
  });
  
  return {
    start: () => {
      audioChunks.length = 0;
      mediaRecorder.start();
    },
    stop: () => mediaRecorder.stop(),
    stream
  };
}
```

## Browser Compatibility and Limitations

### Web Audio API Compatibility
- **Overall Browser Support**: 92% compatibility score
- **Full Support**: Chrome (35+), Edge (12+), Firefox (25+), Opera, Safari

### MediaRecorder API Compatibility
- **Modern Browsers**: Good support in Chrome, Firefox, Edge
- **Safari**: Limited support in older versions
- **Mobile Browsers**: Generally good support in modern versions

### Limitations and Considerations

1. **Audio Format Support**:
   - Chrome supports MP3, WAV, and OGG formats
   - Other browsers may have different codec support
   - WebM is generally well-supported across browsers

2. **Performance Considerations**:
   - ScriptProcessorNode runs on the main thread and can cause performance issues
   - AudioWorklet is preferred for better performance but has slightly less browser support
   - Complex noise generation algorithms can be CPU-intensive

3. **User Permission Requirements**:
   - Microphone access requires explicit user permission
   - Some browsers restrict audio autoplay and initialization

4. **Implementation Recommendations**:
   - Use feature detection before using Web Audio API features
   - Provide fallback mechanisms for unsupported browsers
   - Test across multiple browser environments

## Implementation Examples

### Complete Noise Generator with UI Controls

```javascript
// noise-processor.js
class NoiseProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.noiseType = 'white';
    this.lastOut = 0.0;
    this.pinkState = new Array(7).fill(0);
    
    this.port.onmessage = (event) => {
      if (event.data.type) {
        this.noiseType = event.data.type;
      }
      if (event.data.volume !== undefined) {
        this.volume = event.data.volume;
      }
    };
    
    this.volume = 1.0;
  }
  
  process(inputs, outputs) {
    const output = outputs[0][0];
    
    switch(this.noiseType) {
      case 'white':
        for (let i = 0; i < output.length; i++) {
          output[i] = (Math.random() * 2 - 1) * this.volume;
        }
        break;
        
      case 'pink':
        for (let i = 0; i < output.length; i++) {
          const white = Math.random() * 2 - 1;
          
          this.pinkState[0] = 0.99765 * white + 0.96300 * this.pinkState[0];
          this.pinkState[1] = 0.96300 * white + 0.57000 * this.pinkState[1];
          this.pinkState[2] = 0.57000 * white - 0.06000 * this.pinkState[2];
          this.pinkState[3] = -0.06000 * white - 0.53000 * this.pinkState[3];
          this.pinkState[4] = -0.53000 * white - 0.43000 * this.pinkState[4];
          this.pinkState[5] = -0.43000 * white + 0.15000 * this.pinkState[5];
          this.pinkState[6] = 0.15000 * white + 0.99765 * this.pinkState[6];
          
          output[i] = this.pinkState.reduce((sum, val) => sum + val, 0) * 0.15 * this.volume;
        }
        break;
        
      case 'brown':
        for (let i = 0; i < output.length; i++) {
          const white = Math.random() * 2 - 1;
          output[i] = (this.lastOut + (0.02 * white)) / 1.02;
          this.lastOut = output[i];
          output[i] *= 3.5 * this.volume;
        }
        break;
        
      case 'black':
        for (let i = 0; i < output.length; i++) {
          // Black noise is mostly silence with occasional bursts
          output[i] = (Math.random() > 0.99) ? (Math.random() * 2 - 1) * this.volume : 0;
        }
        break;
    }
    
    return true;
  }
}

registerProcessor('noise-processor', NoiseProcessor);
```

### HTML Interface for Noise Generator and Recorder

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Web Audio API Noise Generator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    .controls {
      margin: 20px 0;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    button {
      padding: 8px 16px;
      margin: 5px;
      cursor: pointer;
    }
    .active {
      background-color: #4CAF50;
      color: white;
    }
    .slider {
      width: 100%;
      margin: 10px 0;
    }
    .recording-controls {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #ddd;
    }
    #recordings {
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1>Web Audio API Noise Generator</h1>
  
  <div class="controls">
    <h2>Noise Type</h2>
    <button id="white" class="noise-type active">White Noise</button>
    <button id="pink" class="noise-type">Pink Noise</button>
    <button id="brown" class="noise-type">Brown Noise</button>
    <button id="black" class="noise-type">Black Noise</button>
    
    <h2>Volume</h2>
    <input type="range" id="volume" class="slider" min="0" max="1" step="0.01" value="0.5">
    <span id="volume-value">50%</span>
    
    <h2>Playback</h2>
    <button id="play">Play</button>
    <button id="stop">Stop</button>
  </div>
  
  <div class="recording-controls">
    <h2>Recording</h2>
    <button id="start-recording">Start Recording</button>
    <button id="stop-recording" disabled>Stop Recording</button>
    <p>Recording Format: 
      <select id="format">
        <option value="audio/webm">WebM</option>
        <option value="audio/ogg">OGG</option>
        <option value="audio/mp4">MP4</option>
      </select>
    </p>
  </div>
  
  <div id="recordings">
    <h2>Recordings</h2>
    <ul id="recordings-list"></ul>
  </div>

  <script>
    // Main application code
    async function initApp() {
      let audioContext;
      let noiseGenerator;
      let mediaRecorder;
      let recordingStream;
      let audioChunks = [];
      let isPlaying = false;
      let currentNoiseType = 'white';
      
      // Initialize audio context on user interaction
      document.getElementById('play').addEventListener('click', async () => {
        if (!audioContext) {
          try {
            audioContext = new AudioContext();
            await setupNoiseGenerator();
          } catch (error) {
            console.error('Error initializing audio:', error);
            return;
          }
        }
        
        if (!isPlaying) {
          audioContext.resume();
          isPlaying = true;
          document.getElementById('play').classList.add('active');
          document.getElementById('stop').classList.remove('active');
        }
      });
      
      document.getElementById('stop').addEventListener('click', () => {
        if (audioContext && isPlaying) {
          audioContext.suspend();
          isPlaying = false;
          document.getElementById('play').classList.remove('active');
          document.getElementById('stop').classList.add('active');
        }
      });
      
      // Noise type selection
      document.querySelectorAll('.noise-type').forEach(button => {
        button.addEventListener('click', () => {
          document.querySelectorAll('.noise-type').forEach(b => b.classList.remove('active'));
          button.classList.add('active');
          currentNoiseType = button.id;
          
          if (noiseGenerator) {
            noiseGenerator.port.postMessage({ type: currentNoiseType });
          }
        });
      });
      
      // Volume control
      const volumeSlider = document.getElementById('volume');
      const volumeValue = document.getElementById('volume-value');
      
      volumeSlider.addEventListener('input', () => {
        const volume = parseFloat(volumeSlider.value);
        volumeValue.textContent = `${Math.round(volume * 100)}%`;
        
        if (noiseGenerator) {
          noiseGenerator.port.postMessage({ volume });
        }
      });
      
      // Recording controls
      document.getElementById('start-recording').addEventListener('click', async () => {
        if (!audioContext) {
          try {
            audioContext = new AudioContext();
            await setupNoiseGenerator();
          } catch (error) {
            console.error('Error initializing audio:', error);
            return;
          }
        }
        
        try {
          const format = document.getElementById('format').value;
          await startRecording(format);
          document.getElementById('start-recording').disabled = true;
          document.getElementById('stop-recording').disabled = false;
        } catch (error) {
          console.error('Error starting recording:', error);
        }
      });
      
      document.getElementById('stop-recording').addEventListener('click', () => {
        stopRecording();
        document.getElementById('start-recording').disabled = false;
        document.getElementById('stop-recording').disabled = true;
      });
      
      // Setup noise generator
      async function setupNoiseGenerator() {
        try {
          await audioContext.audioWorklet.addModule('noise-processor.js');
          noiseGenerator = new AudioWorkletNode(audioContext, 'noise-processor');
          noiseGenerator.connect(audioContext.destination);
          
          // Set initial values
          noiseGenerator.port.postMessage({ 
            type: currentNoiseType,
            volume: parseFloat(volumeSlider.value)
          });
          
          return true;
        } catch (error) {
          console.error('Error setting up noise generator:', error);
          return false;
        }
      }
      
      // Recording functions
      async function startRecording(mimeType) {
        // Create a new audio context for recording
        const recordingContext = new AudioContext();
        
        // Get microphone access
        const micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Create a media stream destination node
        const destination = recordingContext.createMediaStreamDestination();
        
        // Connect noise generator to destination
        if (noiseGenerator) {
          const source = recordingContext.createMediaStreamSource(micStream);
          source.connect(destination);
        }
        
        // Check if the specified MIME type is supported
        if (!MediaRecorder.isTypeSupported(mimeType)) {
          console.warn(`${mimeType} is not supported, falling back to default`);
          mimeType = '';
        }
        
        // Create MediaRecorder
        recordingStream = destination.stream;
        mediaRecorder = new MediaRecorder(recordingStream, { mimeType });
        
        // Clear previous chunks
        audioChunks = [];
        
        // Handle dataavailable event
        mediaRecorder.addEventListener('dataavailable', event => {
          audioChunks.push(event.data);
        });
        
        // Handle recording stop
        mediaRecorder.addEventListener('stop', () => {
          // Create blob from chunks
          const audioBlob = new Blob(audioChunks, { type: mimeType || 'audio/webm' });
          
          // Create URL for the blob
          const audioUrl = URL.createObjectURL(audioBlob);
          
          // Add to recordings list
          addRecordingToList(audioUrl, mimeType);
          
          // Clean up
          recordingStream.getTracks().forEach(track => track.stop());
        });
        
        // Start recording
        mediaRecorder.start();
      }
      
      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
        }
      }
      
      function addRecordingToList(audioUrl, mimeType) {
        const extension = mimeType.includes('webm') ? 'webm' : 
                          mimeType.includes('ogg') ? 'ogg' : 
                          mimeType.includes('mp4') ? 'mp4' : 'bin';
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `noise-recording-${timestamp}.${extension}`;
        
        const recordingsList = document.getElementById('recordings-list');
        const listItem = document.createElement('li');
        
        // Create audio element
        const audio = document.createElement('audio');
        audio.src = audioUrl;
        audio.controls = true;
        
        // Create download link
        const downloadLink = document.createElement('a');
        downloadLink.href = audioUrl;
        downloadLink.download = filename;
        downloadLink.innerText = `Download (${extension})`;
        downloadLink.style.marginLeft = '10px';
        
        // Add to list
        listItem.appendChild(audio);
        listItem.appendChild(downloadLink);
        recordingsList.appendChild(listItem);
      }
    }
    
    // Initialize app when DOM is loaded
    document.addEventListener('DOMContentLoaded', initApp);
  </script>
</body>
</html>
```

## Conclusion

The Web Audio API provides powerful capabilities for generating different types of noise and recording audio in web browsers. The key differences between noise types lie in their spectral characteristics, with white noise having equal energy across all frequencies, pink noise having energy inversely proportional to frequency, and brown noise emphasizing lower frequencies even more.

For modern web applications, the recommended approach is to use AudioWorklet for noise generation, as it provides better performance by running audio processing off the main thread. The MediaRecorder API offers straightforward methods for recording audio in various formats.

When implementing noise generation and recording functionality, it's important to consider browser compatibility and provide appropriate fallbacks. Testing across different browsers and devices is essential to ensure a consistent user experience.

By understanding the mathematical principles behind different noise types and leveraging the capabilities of the Web Audio API, developers can create sophisticated audio applications that generate, process, and record high-quality audio directly in the browser.